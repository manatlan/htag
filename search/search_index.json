{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"HTag","text":"<p>... Docs are coming (2024/03/1) ... ;-)</p> <p>Meanwhile, you can learn a lot on htag's demo ... or better try/repl your self (it's an htag app, running with the runner PyScript, in a simple html page, which provide examples in an html editor) ;-)</p>"},{"location":"#quick-start","title":"Quick start","text":"<p>Just pip the htag lib, from pypi.org</p> <pre><code>$ pyhon3 -m pip install htag -U\n</code></pre> <p>Create a starter app ;-)</p> <p><pre><code>$ pyhon3 -m htag\n</code></pre> (it will create a \"main.py\" basic htag app)</p> <p>Start the app :</p> <pre><code>$ pyhon3 -m htag main.py\n</code></pre> <p>It will run the app, in a \"basic UI\" (open a tab in your default browser), in \"developping mode\" (\"hot reload\" while pressing F5/refresh, and htag errors popups in a nice message )</p> <p>IRL, you should define your Runner to not launch in \"developping mode\" ! Edit your \"main.py\" like that :</p> <pre><code>...\nif __name__==\"__main__\":\n    Runner(App,interface=(640,480)).run()\n</code></pre> <p>And run it like that :</p> <pre><code>$ pyhon3 main.py\n</code></pre> <p>Note :</p> <ul> <li>REAL MODE, no \"developping mode\", pressing F5 will not recreate instances (the app), and \"errors\" will be ignored silently in UI.</li> <li>here, it will run the \"UI part\" in a \"chrome app mode\" (healess chrome) (you'll need to have chrome installed, but it will fallback to a normal tab in default browser if not.</li> <li>The Runner got a lot of options ;-)</li> <li> <p>There are more Runners. But :</p> <ul> <li>if you want to make a \"web app\" (for many users) you should use htagweb</li> <li>if you want to make an Android (smarthpone/TV) app, you should use htagapk</li> </ul> </li> </ul> <p>Now, you can continue on tutorial ;-)</p>"},{"location":"#concept","title":"Concept","text":"<p>You can see it like a python way to create apps, which can use the best of python world, and the best of html/javascript world. And best of all, you can easily create apps (same codebase!) that will work in desktop, android &amp; web world (&amp; html only too (thansk to PyScript )) .</p> <p>The concept is simple : you create UI python classes, which inherits from <code>htag.Tag.&lt;html_tag&gt;</code> (which nativly render html/js/css, and provides minimal dom manipulation api). You can craft components, by reusing other components. Your main component is called the htag app.</p> <p>And you run your htag app, with a htag.runner ... (which will create an instance of it) ... And htag (the renderer part) will manage interactions between the client side and the python side. At each states change in python side, the rendering changes are done on client side. The 2 sides are keeped synchronous ! It only redraws components which has changed !</p> <p>Of course, htag components can (or must) reuse htag components, and will enforce you to create them, to separate your UI logics... and build your own set of reusable components ! That's why htag is more taggued as an \"UI Toolkit to build UI tookit\", than an \"UI toolkit to build GUI\".</p> <p>The (far from) perfect example is htbulma, which is a set of \"ready-to-use htag components\", to build GUI from ground. It uses htag, and provide UI components, usable without (too many)knowledgement of html/js/css world.</p>"},{"location":"calling_an_event/","title":"Calling an event : the complete guide ;-)","text":"<p>After months of use, and more than 100 htag apps later, here are my notes ;-)</p> <p>TODO: talk about the \"ev\" mechanism introduced in \"htag 0.100.x\"</p>"},{"location":"calling_an_event/#first-of-all","title":"First of all","text":"<p>You should really understand than setting an onclick event, is just a javascript call. So this thing will work as expected, on client side :</p> <p><pre><code>from htag import Tag\n\nclass App(Tag.body):\n    def init(self):\n        self+=Tag.button(\"click\",_onclick=\"alert(42)\")\n</code></pre> It will call a javascript statement <code>alert(42)</code>, which will display a js alert box. It's the base. But it's not a htag interaction ... just a js interaction.</p>"},{"location":"calling_an_event/#the-simple-way","title":"The simple way ...","text":"<p>to call an htag interaction ... could be:</p> <pre><code>from htag import Tag\n\nclass App(Tag.body):\n    def init(self):\n        self += Tag.button(\"click\", _onclick=self.clicked)\n\n    def clicked(self, object_which_has_emitted_the_event):\n        print( object_which_has_emitted_the_event )\n</code></pre> <p>The <code>_onclick</code> parameter declares the callback on the \"onclick\" event of the button. When you click the button, htag will emit an \"interaction\" between the GUI/client_side and the back/serverside/your_python_code. In the callback : the first, and only argument, is the instance of the object which has emitted the event.</p> <p>This kind of interaction is called \"direct\" : the callback is directly called during the interaction.</p> <p>For your interest ... it exactly the same construction as</p> <p><pre><code>    def init(self):\n        button=Tag.button(\"click\")\n        button[\"onclick\"]=button.bind( self.clicked ) # declare event, post button construction\n        self += button\n</code></pre> The method <code>&lt;instance&gt;.bind( method, **args, **kargs )</code> is the natural way to bind an \"event\", in all cases.</p> <p>BTW, I think it's a good practice to not poluate the inner namespaces of the instance, by declaring methods which has only one client. Here we could do: (as is, you keep your code more consistant, and less confusing) <pre><code>from htag import Tag\n\nclass App(Tag.body):\n    def init(self):\n\n        def clicked(object_which_has_emitted_the_event):\n            print( object_which_has_emitted_the_event )\n\n        self += Tag.button(\"click\", _onclick=clicked)\n</code></pre></p>"},{"location":"calling_an_event/#pass-arguments-in-direct-calls","title":"Pass arguments (in 'direct' calls)","text":"<p>If you want to pass arguments : a really good practice is to set them on the instance of the object, and get back in the callback.</p> <pre><code>from htag import Tag\n\nclass App(Tag.body):\n    def init(self):\n        self += Tag.button(\"click A\", my_arg=\"A\", _onclick=self.clicked)\n        self += Tag.button(\"click B\", my_arg=\"B\", _onclick=self.clicked)\n\n    def clicked(self, object_which_has_emitted_the_event):\n        print( object_which_has_emitted_the_event.my_arg )\n</code></pre> <p>It's a really good practice to adopt this kind of technics, for 95% of your events, and you keep your code simple and conscise.</p>"},{"location":"calling_an_event/#pass-arguments-using-the-bind-in-direct-calls","title":"Pass arguments, using the \"bind\" (in 'direct' calls)","text":"<p>As seen before, the method <code>&lt;instance&gt;.bind( method, **args, **kargs )</code> can make a lot for you.</p> <p>You could do :</p> <p><pre><code>from htag import Tag\n\nclass App(Tag.body):\n    def init(self):\n        button1=Tag.button(\"click\")\n        button1[\"onclick\"]=button1.bind( self.clicked, \"A\" )\n        self += button1\n\n        button2=Tag.button(\"click\")\n        button2[\"onclick\"]=button2.bind( self.clicked, \"B\" )\n        self += button2\n\n    def clicked(self, object_which_has_emitted_the_event, my_arg):\n        print( my_arg )\n</code></pre> Here, the argument is passed during the interaction, to the callback.</p> <p>It's not really a good practice, when you need to transfer python values ... Prefer the previous method (It's more readable, and avoid to have bigger interactions) !</p> <p>This kind of form is needed when you want to send back javascript values</p> <p>Example : if you want to get back an input value in real time</p> <p>using the b'trick, to ask htag to get a javascript statement. This trick let you declare statements (as byte string) which will be interpreted as a \"javascript statement\". It's really handy to interact easily, in bind methods only.</p> <p><pre><code>class App(Tag.body):\n    def init(self):\n        input=Tag.input(_value=\"\")\n        input[\"onkeyup\"]=input.bind( self.changed, b\"this.value\" )\n        self += input\n\n    def changed(self, object_which_has_emitted_the_event, own_value):\n        print( own_value )\n</code></pre> It's the \"only way\" (not really ... but the proper way, for sure), to get back a information from the client_side/javascript.</p> <p>Another regular use of this form is :</p> <pre><code>class App(Tag.body):\n    def init(self):\n        self+=Tag.input(_value=\"\",_onkeyup=self.bind( self.changed, b\"this.value\" ))\n\n    def changed(self, own_value):\n        print( own_value )\n</code></pre> <p>note that the event onkeyup is binded on the self (not on the button as previously), so the object which send the event is 'self' ... and thus, the self is the object_which_has_emitted_the_event.</p> <p>This kind of approach is more component oriented, when you want to make beautiful component.</p>"},{"location":"calling_an_event/#passing-arguments-in-undirect-calls","title":"passing arguments (in \"undirect calls\"))","text":"<p>Another regular approach, is to create a callback on the event : so the callback is called after the interaction.</p> <p>But in all theses \"undirect calls\" : you can't get back values from client_side/javascript ...</p> <pre><code>class App(Tag.body):\n    def init(self):\n        self += Tag.button(\"click\", _onclick=lambda object_which_has_emitted_the_event: self.clicked(\"A\"))\n        self += Tag.button(\"click\", _onclick=lambda object_which_has_emitted_the_event: self.clicked(\"B\"))\n\n    def clicked(self, my_val):\n        print( my_val )\n</code></pre> <p>or better (setting arguments in instance itself:</p> <pre><code>class App(Tag.body):\n    def init(self):\n        for i in \"ABCDEF\":\n            self += Tag.button(i, value=i, _onclick=lambda object_which_has_emitted_the_event: self.clicked( object_which_has_emitted_the_event.value ))\n\n    def clicked(self, my_val):\n        print( my_val )\n</code></pre>"},{"location":"calling_an_event/#the-oldhistoric-way","title":"The old/historic way","text":"<p>There is another way to do things, it's historical, it comes from the old gtag. But sometimes it's usefull too.</p> <p>In gtag, the way to bind an event was .... here in htag :</p> <pre><code>class App(Tag.body):\n    def init(self):\n        self += Tag.button(\"click\", _onclick=self.bind.clicked() )\n\n    def clicked(self):\n        print( \"hello\" )\n</code></pre> <p>and if you want to pass \"python parameters\" :</p> <pre><code>class App(Tag.body):\n    def init(self):\n        self += Tag.button(\"click\", _onclick=self.bind.clicked('hello') )\n\n    def clicked(self, txt):\n        print( txt )\n</code></pre> <p>and if you want to pass \"javascript parameters\" (using the <code>b'trick</code>)</p> <p><pre><code>class App(Tag.body):\n    def init(self):\n        self += Tag.button(\"click\", _onclick=self.bind.clicked(b'window.innerWidth') )\n\n    def clicked(self, txt):\n        print( txt )\n</code></pre> The <code>&lt;instance&gt;.bind.&lt;method&gt;(*args,**kargs)</code> return a string (a javascript statement to do an interaction). The 'method' must be declared on self instance. It's a lot simpler, but a lot less powerful.</p> <p>By opposite, the <code>&lt;instance&gt;.bind( &lt;method&gt;, *args, **kargs)</code> return a Caller Object, which is rendered as a string (javascript statement). This second form is more versatile, because you can bind any python/callback method. And build better abstractions/components. But sometimes, you'll need to bind a real binded method ... which is not possible in some cases with this second form (during construction phases)</p> <p>BE AWARE : if you are in a construction phase (<code>init(self)</code> or <code>__init__(self)</code>). New mechanisms (<code>&lt;instance&gt;.bind( &lt;method&gt;, *args, **kargs)</code>) can't work, because, at this time, in many cases, we don't know the parent/root of the instance ;-()</p> <p>In that cases, the <code>&lt;instance&gt;.bind.&lt;method&gt;(*args,**kargs)</code> give better results.</p>"},{"location":"calling_an_event/#the-caller-object","title":"The Caller object","text":"<p>The Caller object (returned by the form <code>&lt;instance&gt;.bind( &lt;method&gt;, *args, **kargs)</code>) is (very) usefull. Because, you can chain events, and you can add customized javascript calls.</p> <p>Here is an example of an interaction AND a post javascript statement.</p> <p><pre><code>class App(Tag.body):\n    def init(self):\n        self+=Tag.button(\"right click\",_oncontextmenu=self.bind( self.clicked )+\"return false\")\n\n    def clicked(self):\n        print( \"right clicked\" )\n</code></pre> If you right click on the button, it will produce an htag interaction, and will stop the event (prevent to display the real/default contextmenu). In 99% of my cases, I use this, for my \"oncontextmenu\" events</p> <p>Here is an example of chaining events.</p> <p><pre><code>class App(Tag.body):\n    def init(self):\n        self+=Tag.button(\"click\",_onclick=self.bind( self.clicked ).bind( self.clicked2))\n\n    def clicked(self):\n        print( \"clicked\" )\n    def clicked2(self):\n        print( \"clicked2\" )\n</code></pre> It's very rare to use this feature. But can be usefull in complex components, to chain others treatments. BTW, it produces only one htag interaction (by opposite of the old form, where you could do the same, like <code>_onclick=self.bind.clicked()+\";\"+self.bind.clicked2()</code> ... but avoid that, it makes 2 htag interactions !)</p> <p>And of course, you can mix them</p>"},{"location":"calling_an_event/#others-ways-using-tagjs-property","title":"Others ways (using <code>Tag.js</code> property)","text":"<p>Each htag's Tag instance got a 'js' property. This js property can contain javascript to be executed at each Tag rendering.</p> <p>Here is a very classical use : <pre><code>class App(Tag.div):\n    def init(self):\n        self+=Tag.input(_value=\"default\", js=\"self.focus()\") # here the .js is for the input.\n</code></pre></p> <p>So, every time the Tag 'App' is rendered, it creates an input field, and take the focus (<code>self</code> is a special js var, in this context, to quickly access to the input element)</p> <p>For versions &lt;= 0.9.13 : the <code>self</code> was named <code>tag</code> (which worked too). You could use both, to refer to the js/nodeElement of the tag, but prefer to use <code>self</code> ;-) For versions &lt;= 0.13.0 : the <code>self</code>, and <code>tag</code> was accepted For versions &gt; 0.20.0 : only <code>self</code> ;-)</p> <p>Another approach could be :</p> <p><pre><code>class App(Tag.div):\n    def init(self):\n        self+=Tag.input(_value=\"default\" )\n        self.js = \"self.childNodes[0].focus()\"\n</code></pre> In this case, it's the App Tag which use its js property to set the focus on its child (in a js way) (<code>self</code> is a special js var, in this context, to quickly access to the App/Tag.div js/nodeElement)</p> <p>So, this js property can send back data from client_side/gui too.</p> <p>Here is an example :</p> <p><pre><code>class App(Tag.body):\n    def init(self):\n        self.js = self.bind.starting( b'window.innerWidth' )\n\n    def starting(self,width):\n        print(\"innerWidth\",width)\n</code></pre> As seen before, the newest <code>&lt;instance&gt;.bind( &lt;method&gt;, *args, **kargs)</code> couldn't be used for this purpose. Keep in mind, that this form should be used in binding events (because it needs to be \"attached\" in the dom tree)</p>"},{"location":"calling_an_event/#others-ways-using-tagcall-method","title":"Others ways (using <code>Tag.call</code> method)","text":"<p>Each htag's Tag instance got a a <code>&lt;instance&gt;.call(js)</code> method to send an UNIQUE custom js statements during an interaction.</p> <p>It's a little weird here. But it's really important to understand the difference between <code>self.js=\"js_statement()\"</code> and <code>self.call(\"js_statement()\")</code>.</p> <ul> <li><code>self.js=\"js_statement()\"</code>: will execute the JS at each rendering of the object (ex: some html object (those from materialize need to be initialized with javascript statements, it's the perfect way to do that, in that place)</li> <li><code>self.call(\"js_statement()\")</code> : will execute the JS one time (when it's called) (ex: some html object need to change its aspect thru js call ... think : close a menu, etc ...)</li> </ul> <p>So, this thing will work as the previous one .. except ..</p> <p><pre><code>class App(Tag.body):\n    def init(self):\n        self.call( self.bind.starting( b'window.innerWidth' ) )\n\n    def starting(self,width):\n        print(\"innerWidth\",width)\n</code></pre> Except ... here, the js is sent only at construction time (in previous one : the js is sent at each rendering). The nuance is really subtil.</p> <p>BTW, you can use a simple form (versions &gt;= 0.9.14), which does exactly the same thing ^^: <pre><code>class App(Tag.body):\n    def init(self):\n        self.call.starting( b'window.innerWidth' )\n\n    def starting(self,width):\n        print(\"innerWidth\",width)\n</code></pre> Here : <code>self.call.starting( b'window.innerWidth' )</code> is the short form for <code>self.call( self.bind.starting( b'window.innerWidth' ) )</code>, it's exactly the same !</p> <p>IMPORTANT : The last 2 examples are BAD PRACTICE, because the <code>self.call</code> (during construction phase) can only work when it's in the main tag (which is managed by the Runner (TODO:link)). If it was in an <code>init</code> from a component : it can't work (because we don't know the parent/root at this time). The good practice is DON'T USE <code>self.call</code> IN A CONSTRUCTOR (prefer <code>self.js</code>)</p>"},{"location":"calling_an_event/#using-the-event-properties-from-guijs","title":"Using the <code>event</code> properties from gui/js","text":"<p>Some times, it can be usefull to get back the properties of the js event, when you want to get back the key pressed, or the x/y coordinates of a click, etc ...</p> <p>Theses properties are stocked in the \"event\" property of an HTag instance, as a dict (during an interaction).</p> <p>You can display them, like that:</p> <pre><code>from htag import Tag\n\nclass App(Tag.body):\n    def init(self):\n        self += Tag.button(\"click\", _onclick=self.clicked)\n\n    def clicked(self, o):\n        print( o.event )\n</code></pre>"},{"location":"calling_an_event/#using-the-expose-decorator","title":"Using the <code>@expose</code> decorator","text":"<p>See @expose !</p> <p>...TODO...</p>"},{"location":"concepts/","title":"Concepts","text":"<p>Here are the concepts, for 1.0 version. (but all is here since 0.8.15) (For now, some concepts are presented in tutorial. But here, it's my global plan to make a minimal doc ;-) )</p>"},{"location":"concepts/#technically","title":"Technically","text":"<p>HTag let you easily build UI elements/widgets (using HTML technologies under the hood), and display them in any things which can render HTML (thru runners).</p> <p>In fact, it will render it as a SPA, and will manage all interactions for you (between the UI and the python code), without much knowledgement in html/js/css techs.</p> <p>Everything is done in 3 layers :</p> <ul> <li><code>Tag</code>: the module to build your UI (it's a metaclass to build html/htag components)</li> <li><code>HRenderer</code> : the abstraction layer between <code>Tag</code> (^) and <code>Runner</code> (v) (which make all the magic). You can forget it.</li> <li><code>Runner</code> : the process which will run the main tag (AKA the htag app) in a context.</li> </ul> <p>The <code>Runner</code> will manage the underlying communications between the UI (the front (python htag &gt; html)), and the python code (the back (python)), in differents manners, depending on the <code>Runner</code> which is used. (ex: Some use HTTP only, some use HTTP or WS, some use inproc/direct calls ... depending of the technologies used by the <code>Runner</code>)</p> <p>There are a lot of runners, which comes OOTB with htag. Just grab the one which suit your needs. All you need to know is how to build a GUI App with the <code>htag.Tag</code>, and it's the purpose of this page ;-)</p> <p>But the main concept is here: you can developp an Htag App which will work anywhere; as a web app, as a desktop app, or as an android app : it will be the same codebase (just depending on the <code>Runner</code> context)</p> <p>It can be seen as a \"VueJs|Angular|React\" framework on python side; a statefull instance which manage/render htag's components (states changes are handled by the interactions between the front and the back)</p>"},{"location":"concepts/#tag-construction","title":"Tag construction","text":"<p><code>htag.Tag</code> is a metaclass helper to build an html tag.</p> <p><pre><code>from htag import Tag\n\nmydiv = Tag.div(\"hello world\")\n</code></pre> <code>mydiv</code> will produce a html ouptut as <code>&lt;div&gt;hello world&lt;/div&gt;</code> ;-)</p> <p>The firt parameter is the default content of the object, and can be everything (which have a <code>__str__</code> method)</p> <p>Here are some others tag constructions :</p> <p><pre><code>Tag.div(42)                           # --&gt; &lt;div&gt;42&lt;/div&gt;\nTag.div()                             # --&gt; &lt;div&gt;&lt;/div&gt;\nTag.div( \"hello \" + Tag.b(\"world\") )  # --&gt; &lt;div&gt;hello &lt;b&gt;world&lt;/b&gt;&lt;/div&gt;\nTag.what_you_want(\"hello\")            # --&gt; &lt;what-you-want&gt;hello&lt;/what-you-want&gt;\n</code></pre> . . .</p> <ul> <li>TODO: (and inherit open/closed (the <code>**a</code> trick))</li> <li>TODO: (placeholder)</li> </ul>"},{"location":"concepts/#tag-properties-parent-and-root","title":"Tag properties : parent and root","text":"<ul> <li>TODO: (warn root in init !)</li> <li>TODO: (strict mode)</li> </ul>"},{"location":"concepts/#run-javascript","title":"Run javascript","text":"<ul> <li>TODO: @expose decorator</li> <li>TODO: self.js vs self.call( Js ) (and tag js var)</li> </ul>"},{"location":"concepts/#bind-events","title":"Bind events","text":"<ul> <li>TODO: (four ways, chaining bind, chaining Js before/after)</li> <li>TODO: (use b'' for javascript)</li> </ul>"},{"location":"concepts/#events-in-python-side","title":"Events (in python side)","text":"<ul> <li>TODO: sync/async and yield</li> <li>TODO: and stream (adding tag with yield)</li> </ul>"},{"location":"concepts/#include-statics","title":"Include statics","text":"<ul> <li>TODO: howto, and shortcuts for js/style</li> <li>TODO: and imports trick</li> </ul>"},{"location":"concepts/#rendering-lately-vs-dynamic","title":"rendering lately vs dynamic","text":"<ul> <li>TODO: main.tag setted as body</li> <li>TODO: in render : avoid tag construction -&gt; coz redraw all (now protected in STRICT_MODE)</li> <li>TODO: ... And hrenderer/runners (and url queryparams)</li> </ul>"},{"location":"concepts/#runners","title":"Runners","text":"<p>url and instanciations - TODO: (and state management) - For now, See runners</p>"},{"location":"creating_a_tag/","title":"Creating a Tag : the complete guide","text":"<p>If you come from domonic or brython : htag borrows the best ideas from them.</p>"},{"location":"creating_a_tag/#the-basics","title":"The basics","text":""},{"location":"creating_a_tag/#at-construction-time","title":"At construction time","text":"<p>A Tag (htag's Tag) is a helper to let you build easily html representation of an object.</p> <p>The signature of the helper could be: <code>Tag.&lt;html&gt;( &lt;content_or_None&gt;, **attrs ) -&gt; htag instance</code>  * Where <code>&lt;html&gt;</code> can be \"div\",\"span\",\"input\", .. or whatever you want (it will be the html tag representation)  * Where <code>&lt;content_or_None&gt;</code> can be None or whatever which is str'able (list are accepted too)  * Where <code>attrs</code> can be any attributs to specialize the creation (see later)</p> <p><pre><code>from htag import Tag\n\nprint( Tag.div(\"hello world\") )\n</code></pre> Will generate <code>&lt;div&gt;hello world&lt;/div&gt;</code> ... easy ;-)</p> <p>If you want to set html attributs, prefix them with '_'</p> <p><pre><code>print( Tag.div(\"hello world\", _style=\"background:yellow\") )\n</code></pre> Will generate <code>&lt;div style=\"background:yellow\"&gt;hello world&lt;/div&gt;</code> ;-)</p> <p>It will work for every kind of html attributs, and events too</p> <p><pre><code>print( Tag.div(\"hello world\", _onclick=\"alert(42)\") )\n</code></pre> Will generate <code>&lt;div onclick=\"alert(42)\"&gt;hello world&lt;/div&gt;</code> ;-)</p> <p>You can construct whatever tag you want ...</p> <p><pre><code>print( Tag.my_tag(\"hello world\", _class=\"mine\") )\n</code></pre> Will generate <code>&lt;my-tag class=\"mine\"&gt;hello world&lt;/my-tag&gt;</code> (notice that the <code>_</code> is replaced by <code>-</code> ;-)</p> <p><pre><code>print( Tag.span(\"hello world\", _val=12, _checked=True) )\n</code></pre> Will generate <code>&lt;span val=\"12\" checked&gt;hello world&lt;/span&gt;</code> !</p> <p>It's simple ;-)</p> <p>But you can init some instance properties at construction time ... <pre><code>tag = Tag.span(\"hello world\", value=12, _value=42 )\nprint( tag )\n</code></pre> Will generate <code>&lt;span value=\"42\"&gt;hello world&lt;/span&gt;</code>, but the instance var (here <code>tag</code>) will contain 12 ( tag.value==12 ) ! So <code>_value</code> is an html attribut ... whereas <code>value</code> is an instance property (on python side only). It's important to understand the difference.</p> <p>Take a break, and medit on that ;-)</p> <p>You can compose tags ... <pre><code>Tag.div( Tag.span(\"hello\")+\" \"+Tag.b(\"world\") )\n# or\nTag.div( [Tag.span(\"hello\"),\" \",Tag.b(\"world\")] )\n</code></pre> it's basically the same thing ^^</p>"},{"location":"creating_a_tag/#post-construction-time","title":"Post construction time","text":"<p>all this variables are usable/settable post construction time. <pre><code>tag = Tag.span(\"hello world\", value=12, _value=42 )\nassert tag[\"value\"]==42\nassert tag.value==12\n</code></pre> html attributs are in the dictitem of the tag ! Whereas the instance properties are in the instance ;-)</p> <p>So you can do that: <pre><code>tag = Tag.a(\"hello world\")\ntag[\"onclick\"]=\"alert(42)\"\n</code></pre> And you can compose them like that :</p> <pre><code>div=Tag.div()\ndiv.add( Tag.span(\"hello\") )\ndiv.add( \" \" )\ndiv.add( Tag.b(\"world\") )\n</code></pre> <p>but there are operators (<code>+=</code> (prefer) or <code>&lt;=</code> (brython style)), to simplify that : <pre><code>div = Tag.div()\ndiv += Tag.span(\"hello\")\ndiv += \" \"\ndiv += Tag.b(\"world\")\n</code></pre></p> <p>easy, no ?</p> <p>BTW, you can use the <code>with/as</code> statement, like that (since htag&gt;=0.13):</p> <pre><code>with Tag.div() as t:\n    t += Tag.span(\"hello\")\n    t += \" \"\n    t += Tag.b(\"world\")\n    t[\"style\"]=\"background:#EEE\"\n</code></pre>"},{"location":"creating_a_tag/#irl-in-a-runner-context","title":"IRL (in A Runner Context)","text":"<p>An important thing to understand, is that a Tag renders differently when used in a runner (TODO:LINK). AS you see before, the tags are rendered without attributs 'id'. But, IRL, when using in a htag runner context, all tags are rendered with an html id attribut (it's the main reason why you can't set an <code>_id</code> at runtime !). Htag's runner manage all the tags, with theirs ids: it's the core feature, to be able to keep states/rendering between the gui/client_side and the back/python ;-)</p> <p>When used in a Runner Context, some specials properties are setted on a Tag.  * <code>root</code> : Contains the instance of the main tag (AKA the one drived by the HTag's Runner)  * <code>parent</code> : Contains the instance of the parent tag (AKA the one which had added it)</p> <p>The <code>root</code> is very usefull, to refer global properties/methods from a single place. The <code>parent</code> can be usefull in complex components which involve other tree components.</p> <p>But BE AWARE : theses properties are only setted at rendering time ! Not a construction time : in others terms -&gt; you can't use them in a construction phase ! It really important to understand that!</p>"},{"location":"creating_a_tag/#inherit-a-tag","title":"Inherit a Tag","text":"<p>It's really the main goal of htag : be able to create feature rich components in python style, to be reusable in others apps.</p> <p>here is a simple div construction: <pre><code>Tag.div('hello',_style=\"background:red\")\n</code></pre></p> <p>Here is the same, using inheritance (to create a <code>Div</code> class) :</p> <p><pre><code>class Div(Tag.div):\n    def init(self):\n        self += \"hello\"\n        self[\"style\"]=\"background:red\"\n</code></pre> Both rendering exactly the same kind of result.</p> <p>Here, you will notice that it uses a special constructor (<code>init</code>) in place of the real python constructor (<code>__init__</code>). It's just to simplify the process. If you want to use the real python constructor, you can do (but it's longer):</p> <p><pre><code>class Div(Tag.div):\n    def __init__(self):\n        super().__init__()\n        self += \"Hello world\"\n        self[\"style\"]=\"background:red\"\n</code></pre> It produces exactly the same kind of result.</p> <p>Now, when you want to use your new component, it's as simple as always :</p> <pre><code>class App(Tag.body):\n    def init(self):\n        self += Div()\n</code></pre> <p>Now, an important thing to understand : this component 'Div' is said \"closed\", because you can't specialize it (with html attributs, or instance properties) at construction time. You can't reuse it like that:</p> <pre><code>class App(Tag.body):\n    def init(self):\n        self += Div(_class=\"myclass\")   # will throw an exception (because it's closed)\n</code></pre> <p>Because 'Div' doens't accept something in its constructor. So we say that it's \"closed\".</p> <p>If you wanted to make you component \"opened\" (by opposite : to accept html attributs, or instance properties), you should declare it like that : <pre><code>class Div(Tag.div):\n    def init(self,**a):     # notice the '**a' !\n        self += \"hello\"\n        self[\"style\"]=\"background:red\"\n</code></pre></p> <p>With classical python constructor it should be : <pre><code>class Div(Tag.div):\n    def __init__(self, **a):  # notice the '**a' !\n        super().__init__(**a) # notice the '**a' !\n        self += \"Hello world\"\n        self[\"style\"]=\"background:red\"\n</code></pre></p> <p>It's good practice, to create its components in a \"opened\" way (to be able to customized them later). But sometimes, it makes sense to refuse customization.</p> <p>BTW, keep in mind, that in all cases (\"opened\" or \"closed\"), you can customize them after creation. <pre><code>class App(Tag.body):\n    def init(self):\n        div=Div()\n        div[\"class\"]=\"myclass\"  # &lt;- like that\n        self += div\n</code></pre></p>"},{"location":"creating_a_tag/#create-a-dynamic-tag-using-a-renderself-method","title":"Create a dynamic tag (using a <code>render(self)</code> method)","text":"<p>You can create a component which will auto render itself on changes. This kind of component is neat for small component. This kind of component are named \"dynamic\" component, and to be a dynamic component : it must implement a <code>render(self) -&gt; None</code>, which will redraw all its content.</p> <p>A simple example: <pre><code>class Starrer(Tag.div):\n    def init(self,value=0):\n        self.value=value\n\n        def inc(v):\n            self.value+=v\n\n        self.bless = Tag.Button( \"-\", _onclick = lambda o: inc(-1) )\n        self.bmore = Tag.Button( \"+\", _onclick = lambda o: inc(+1) )\n\n    def render(self):\n        self.clear()\n        self += self.bless + self.bmore + (\"\u2b50\"*self.value)\n</code></pre></p> <p>IMPORTANT: AVOID USING <code>Tag.&lt;html&gt;(content,**kargs)</code> IN A render() METHOD !!!!!!! (avoid creating new tag instance, because it will create new instance (new ids), and force rendering at each interaction)</p> <p>See Example c30</p>"},{"location":"creating_a_tag/#creating-a-placeholder-tag","title":"Creating a \"PlaceHolder\" Tag","text":"<p>A placeholder tag : is a Tag \"without outerHTML\", It has no html representation from itself. And its rendering depends on its childs.</p> <p>TODO: say more ;-)</p>"},{"location":"creating_a_tag/#creating-a-tag-generatior-yielding-content","title":"Creating a Tag generatior (yield'ing content)","text":"<p>Sometimes, it can be usefull to render on-demand. Imagine that you want to populate a big list, it will be impossible (or very long). HTag provide a way to do that, to avoid to draw all the html in one interaction. It can render by fragment, using the <code>yield</code> statement.</p> <p>TODO: say more ;-)</p> <p>See Example c90</p> <p>... TODO ...</p>"},{"location":"hrenderer/","title":"HRenderer","text":"<p>It's the class which handle an htag.Tag class, and make it lives in a runner context. It exposes methods for a runner.</p> <p>In general, you don't need to use this class on your own. In general, you will use a 'runner' which will do it for you. If you are here, you will to create your own runner, or see how it works.</p> <p>definitions:</p> <ul> <li>hr : means the HRrenderer instance</li> <li>runner : it's a high level class (which use a hrenderer under-the-hood) to make the magix.</li> </ul>"},{"location":"hrenderer/#def-__init__self-tagclass-type-jsstr-exit_callbackoptionalcallablenone-init-fullerrorfalse-statics-sessionnone","title":"<code>def __init__(self, tagClass: type, js:str, exit_callback:Optional[Callable]=None, init= ((),{}), fullerror=False, statics=[], session=None ):</code>","text":"<p>It's the constructor of an instance ;-)</p> <p>When you got your hr instance : <code>str(hr)</code> will (always) contain a full html page which should work OOTB in a client-side ! It's often called the \"1st rendering\".</p>"},{"location":"hrenderer/#tagclass-htagtag-class","title":"tagClass [htag.Tag class]","text":"<p>It's the subclass, which will be instanciate in the hr instance. </p>"},{"location":"hrenderer/#js-str","title":"js [str]","text":"<p>It's a string which define the JS methods to interact with the hr instance, and the way to \"start\" the live of the html page in client side (by calling a js 'start()' method).</p> <p>For a http runner, it's often like that: <pre><code>async function interact( o ) {\n    action( await (await window.fetch(\"/\",{method:\"POST\", body:JSON.stringify(o)})).text() )\n}\n\nwindow.addEventListener('DOMContentLoaded', start );\n</code></pre></p> <p>For a websocket runner, it's often like that:</p> <pre><code>async function interact( o ) {\n    ws.send( JSON.stringify(o) );\n}\nvar ws = new WebSocket(\"ws://\"+document.location.host+\"/ws\");\nws.onopen = start;\nws.onmessage = function(e) {\n    action( e.data );\n};\n</code></pre> <p>There are 3 main ideas, in this js str :</p> <ul> <li>provide a js 'interact' method, which will pass its arguments, to python (back side)</li> <li>provide the way to call the <code>action( &lt;dict&gt; )</code> from the python response (back side)</li> <li>define how to call the 'start()' method</li> </ul> <p>Remarks  - start() and action(  ) are js methods provided by the \"1st rendering\"  - as you can see :      - The http form is synchronous (the action is executed with the return of the interact)      - The ws form is asynchronous (the action is executed when a message is sended from the hr to the client side)"},{"location":"hrenderer/#init-tuple","title":"init [tuple] <p>it's the parameters which will be used to initialize the htag.Tag class, in the form (args, *kargs).</p> <p>If it can't instanciate the class with the init parameters, it will try to instanciate it with null parameters ( aka <code>( (), {} )</code>).</p>","text":""},{"location":"hrenderer/#fullerror-boolean","title":"fullerror [boolean] <p>it's a boolean to prevent the hr to send back just the error, or the full stacktrace. </p>","text":""},{"location":"hrenderer/#statics-list","title":"statics [List] <p>It's a list of \"statics\", which will be added in the html&gt;head page of the 1st rendering.</p>","text":""},{"location":"hrenderer/#session-dict","title":"session [dict] <p>It's a dict which will hold the session for the user. It got only sense in the \"web runners\" (those ones manage a session/dict by user). All others runners are mono-user, so the session dict will only be a empty dict.</p>","text":""},{"location":"hrenderer/#exit_callback-method","title":"exit_callback [method] <p>It's a method, which will be called when a user call the tag.exit() method. It got only sense in runners which are mono-user (because it will quit the app). The \"web runners\" dont implement this feature.</p>","text":""},{"location":"hrenderer/#async-def-interactself-id-method_namestr-args-kargs-eventnone-dict","title":"<code>async def interact(self, id, method_name:str, args, kargs, event=None) -&gt; dict:</code>","text":"<p>It's the python method, which must be called thru the 'js' declaration in the hr constructor, to make an \"interaction\" with the tag instance, managed by the hr.</p> <p>In general, you won't need to pass arguments to it because : you just cable the js call</p> <p>Under the hood, this method returns 'actions' (dict), to redraw the client side, and to execute some js. ...</p> <p>TODO I find it ambiguous ... because the reality is simpler !</p>"},{"location":"js_bidirectionnal/","title":"JS bidirectionnal (@expose)","text":"<p>Sometimes, when using a JS lib, with heavy/bidirectionnal interactions : you 'll need to call js and receive events from JS. You can do that by using a <code>@expose</code> decorator.</p> <p>Here is a \"audio player\" tag, which expose a python \"play' method, and a \"event\" method (whil will be decorated) to receive event from the js side. Here is the best way to do it :</p> <pre><code>from htag import Tag, expose\n\nclass APlayer(Tag.div):\n    statics=Tag.script(_src=\"https://cdnjs.cloudflare.com/ajax/libs/howler/2.2.4/howler.min.js\")\n\n    def init(self):\n        self.js=\"\"\"\n\nself.play= function(url) {\n    if(this._hp) {\n        this._hp.stop();\n        this._hp.unload();\n    }\n\n    this._hp = new Howl({\n      src: [url],\n      autoplay: true,\n      loop: false,\n      volume: 1,\n      onend: function() {\n        self.event(\"end\",url);\n      }\n    });\n\n}\n    \"\"\" % self.bind.event(b\"args\")\n\n    def play(self,url):\n        self.call( f\"self.play(`{url}`)\" )\n\n    @expose\n    def event(self,name,url):\n        self+=f\"EVENT: {name} {url}\"\n</code></pre>"},{"location":"query_params/","title":"Instanciating main htag class with url/query params","text":"<p>In most runners, you can use \"query parameters\" (from the url) to instanciate your htag main class.</p> <p>Admit that your main class looks like that :</p> <pre><code>class MyTag(Tag.div):\n    def init(self,name,age=12):\n        ...\n</code></pre> <p>If can point your running App to urls like:</p> <ul> <li><code>/?name=john&amp;age=12</code> -&gt; will create the instance <code>MyTag(\"john\",'12')</code></li> <li><code>/?Jim&amp;42</code> -&gt; will create the instance <code>MyTag(\"Jim\",'42')</code></li> <li><code>/?Jo</code> -&gt; will create the instance <code>MyTag(\"Jo\",12)</code></li> </ul> <p>As long as parameters, fulfill the signature of the constructor : it will construct the instance with them. If it doesn't fit : it try to construct the instance with no parameters !</p> <p>So things like that :</p> <ul> <li><code>/</code> -&gt; will result in http/400, because <code>name</code> is mandatory in all cases !!</li> </ul> <p>BTW, if your class looks like that (with <code>**a</code> trick, to accept html attributes or property instance)</p> <p><pre><code>class MyTag(Tag.div):\n    def init(self,name,age=12,**a):\n        ...\n</code></pre> things like that, will work :</p> <ul> <li><code>/?Jim&amp;_style=background:red</code> -&gt; will create the instance <code>MyTag(\"Jim\",'42')</code>, and change the default bg color of the instance.</li> </ul> <p>So, it's a best practice, to not have the <code>**a</code> trick in the constructor of main htag class (the one which is runned by the runner)</p> <p>Remarks:</p> <ul> <li>all query params are string. It's up to you to cast to your needs.</li> <li>this feature comes with htag &gt;= 0.8.0</li> </ul>"},{"location":"query_params/#try-by-yourself","title":"Try by yourself","text":"<pre><code>from htag import Tag\n\nclass MyApp(Tag.div):\n    def init(self,param=\"default\",**a):\n        self &lt;= f\"Param: {param}\"\n        aa=lambda x: Tag.a(\"test: \"+x,_href=x,_style=\"display:block\")\n        self &lt;= aa(\"?\")\n        self &lt;= aa(\"?rien\")\n        self &lt;= aa(\"?toto\")\n        self &lt;= aa(\"?toto&amp;56\")\n        self &lt;= aa(\"?param=kiki\")\n        self &lt;= aa(\"?nimp=kaka\")\n        self &lt;= aa(\"?tot1#a1\")\n        self &lt;= aa(\"?tot2#a2\")\n        self &lt;= aa(\"?to12&amp;p=12\")\n        self &lt;= aa(\"?tot3&amp;_style=background:red\")\n\nfrom htag.runners import Runner\nRunner(MyApp).run()\n</code></pre> <p>Currently, this feature works in all htag.runners except PyWebView ;-(</p>"},{"location":"runner/","title":"Runner","text":"<p>A minimal doc ... there are a lot to say more. But this page will evolve soon.</p>"},{"location":"runner/#__init__-self-tagclass-file-properties","title":"<code>__init__( self, tagClass, file, ...properties... )</code>","text":"<p>It's the Runner constructor</p>"},{"location":"runner/#tagclasstagnone-none","title":"tagClass:Tag|None = None","text":"<p>It's the tag class you want to be served at \"/\" path. It's the class which will be used to create the first instance when you run your app.</p> <p>A common pattern is : <pre><code>from htag import Tag\n\nclass App(Tag.body):\n    ...\n\nif __name__ == \"__main__\":\n    from htag.runners import Runner\n    Runner(App).run()\n</code></pre> if you don't provide it, ensure that you <code>add_route</code> to the home path \"/\" (if you want to show something when you run your app)</p>"},{"location":"runner/#filestrnone-none","title":"file:str|None = None","text":"<p>Here you can set a filepath to a json/file, if you want to persist your session. Currently it's a json serialization, so ensure that objects you put in session are json serializable</p>"},{"location":"runner/#properties","title":"properties:","text":"<p>Theses properties can be set at contructor time, but are instance properties too (can be set after contructor time).</p>"},{"location":"runner/#hoststr-127001","title":"host:str = \"127.0.0.1\"","text":"<p>The IP of the host, by default it's localhost. But can be \"\" (empty string) to listen world wild (interest ?).</p>"},{"location":"runner/#portint-8000","title":"port:int = 8000","text":"<p>The port of the HTTP/WS transport.</p>"},{"location":"runner/#interface-1","title":"interface = 1","text":"<p>It's the more ambiguous parameter, it can takes 3 values  :</p> <p>If it's 0|False|None -&gt; it will serve forever, without running the UI part (kind of headless mode). And the server will never quit !</p> <p>If it's 1|True|None -&gt; it will start the UI interface (start the default browser to \"/\" path). And the server will autoquit if there are no more interactions (closing the tab -&gt; close the server)</p> <p>If it's a tuple (width,height) -&gt; it will start a chrome app in app mode (chrome in headless mode), using the defined width/height. If it can't (because you don't have chrome on your computer), it will start the default browser. And the server will autoquit if there are no more interactions (closing the app -&gt; close the server)</p> <p>example: running in \"chrome app mode\" (here in a window sized 640x480):</p> <pre><code>...\n\nclass App(Tag.body):\n    ...\n\nif __name__==\"__main__\":\n    from htag.runners import Runner\n    Runner(App,interface=(640,480)).run()\n</code></pre>"},{"location":"runner/#reloadbool-false","title":"reload:bool = False","text":"<p>To be able to \"reload\" (recreate) the instances. Can be really useful during dev process !!! Note that the reloading mechanism only works great when the \"App part\" is in another file, from the \"Runner part\" (to be able to reload by module).</p> <p>So when you hit F5/refresh : it will recreate instances at each refresh ! (in contrario of the default, which always reuse the last instances)</p>"},{"location":"runner/#debugbool-false","title":"debug:bool = False","text":"<p>It's a mechanism which will override the javascript <code>window.error = function() {}</code>, to display a popup when exception comes. Can be really useful during dev process. (in the near future, it will display the exchanges in \"browser debug tools / console.log\", like previous )</p>"},{"location":"runner/#http_onlybool-false","title":"http_only:bool = False","text":"<p>Can be used to force the exchange to be HTTP only (no websocket!) ... (interest ?)</p> <p>When it's HTTP ONLY : the tag.update feature can't work.</p>"},{"location":"runner/#use_first_free_portbool-false","title":"use_first_free_port:bool = False","text":"<p>It's a mechanism to run the \"runner part\" in all cases ! It will use the next free port available if the current one is already used. It can be useful in some cases.</p>"},{"location":"runner/#add_routeselfpathstrhandler-none","title":"<code>add_route(self,path:str,handler) -&gt; None</code>","text":"<p>This method let you create a a new route to be able to serve: - another Tag Class (using <code>self.handle(request, tagClass) -&gt; HTTPResponse</code>, see below) - another http ressource (ex: a jpg, png, html, js ...)</p>"},{"location":"runner/#to-serve-another-tag-class-a-common-pattern-is","title":"To serve another Tag Class, a common pattern is :","text":"<pre><code>from htag import Tag\n\nclass App(Tag.body):\n    ...\n\nclass App2(Tag.body):\n    ...\n\nif __name__ == \"__main__\":\n    from htag.runners import Runner\n    app=Runner(App)\n\n    app.add_route( \"/other\", lambda request: app.handle(request, App2 ) )\n\n    app.run()\n</code></pre> <p>When serving a Tag Class, you can't set \"path parameters\" (things like '/item/{idc}') in the route ! But you can get the query parameters of the url, to initialize your init constructor of your Tag class. Note that \"query parameters\" are also available for your default home route (\"/\").</p>"},{"location":"runner/#to-serve-an-http-ressource-a-common-pattern-is","title":"To serve an http ressource, a common pattern is :","text":"<pre><code>from htag import Tag\n\nclass App(Tag.body):\n    ...\n\nif __name__ == \"__main__\":\n    from htag.runners import Runner, HTTPResponse\n    app=Runner(App)\n\n    async def handlerItem( request ):\n        idx=request.path_params.get(\"idx\",0)        \n        txt=request.query_params.get(\"txt\",\"???\")\n        return HTTPResponse(200,\"Number %d (txt=%s)\" % (idx,txt))\n\n    app.add_route( \"/item/{idx:int}\", handlerItem )\n\n    app.run()\n</code></pre> <p>Note that <code>request</code> have 2 dict property :</p> <ul> <li><code>path_params</code> : to expose path parameters, when defined in routes (as starlette.add_route does)</li> <li><code>query_params</code> : to expose query parameters (ex: https://example.com/item/42?a=42&amp;b=toto -&gt; {\"a\":\"42\",\"b\":\"toto\"})</li> </ul> <p>Note that path params can be :</p> <ul> <li>\"/item/{idx}\" : idx will be str.</li> <li>\"/item/{idx:str}\" : idx will be str.</li> <li>\"/item/{idx:int}\" : idx will be int.</li> <li>\"/item/{idx:path}\" : idx will be the rest of the path (with url \"/item/box/1\", idx will be 'box/1')</li> </ul>"},{"location":"runner/#handleself-request-tagclass-httpresponse","title":"<code>handle(self, request, tagClass ) -&gt; HTTPResponse</code>","text":"<p>It's an internal method, but can be used with <code>self.add_route(path,request)</code> (see upper).</p>"},{"location":"runners/","title":"Runners","text":"<p>The 'Runners' is the htag denomination, for some classes provided with htag, to help you to run a Htag App in a context. Here are the current provided runners, and could give you ideas of what you want ;-)</p> <p>htag provides officialy 3 runners :</p> <ul> <li>Runner : the base one, for desktop app</li> <li>PyScript : the special to be runned in pure html side</li> <li>PyWebView : a specific for desktop using a CEF UI (using pywebview) ... (it could be in another htag module soon)</li> </ul> <p>If you want to create an \"Android app\" (smartphone, tv, etc ...) see htagapk recipes)</p> <p>If you want to create an \"Web app\" (multiple clients) see htagweb runner)</p> <p>Between 0.90 &amp; 1.0 versions, htag provides the old runners (for compatibility reasons), but they are deprecated and will be removed at 1.0. Here they are:</p> <ul> <li>AndroidApp</li> <li>BrowserHTTP</li> <li>BrowserStarletteHTTP</li> <li>BrowserStarletteWS</li> <li>ChromeApp</li> <li>DevApp</li> <li>BrowserTornadoHTTP</li> <li>WinApp</li> </ul> <p>Currently, all are faked/simulated and use the new <code>Runner</code> instead (thus, a runner like BrowserStarletteWS, doesn't use starlette anymore, but the new runner home-made server, which is enough robust for one client/user ;-) )</p>"},{"location":"runners/#runner-runner","title":"Runner 'Runner'","text":"<p>This runner can simulate all old runners. All specialized features, that were in some runners only, are all available now. This runner is a pure python server (holding Websocket/HTTP connexions). Things like uvicorn/starlette/tornado were overbloated for a server which can handle one client ;-)</p> <p>See Runner</p>"},{"location":"runners/#runner-pyscript","title":"Runner 'PyScript'","text":"<p>Run everything in client side, thanks to the marvellous pyscript. Don't know if there is an utility, but it's possible ;-). It should run OOTB, everywhere where pyscript runs.</p> <p>Run your <code>App</code> (htag.Tag class), in a HTML file, like this :</p> <pre><code>&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n&lt;head&gt;\n    &lt;meta charset=\"utf-8\"&gt;\n    &lt;link rel=\"stylesheet\" href=\"https://pyscript.net/releases/2024.10.2/core.css\"&gt;\n    &lt;script type=\"module\" src=\"https://pyscript.net/releases/2024.10.2/core.js\"&gt;&lt;/script&gt;\n    &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1\"&gt;\n&lt;/head&gt;\n&lt;body&gt; loading pyscript ;-)\n&lt;script type=\"py\" config='{\"packages\":[\"htag\"]}'&gt;\n\n###############################################################################\nfrom htag import Tag\n\nclass App(Tag.body):\n    ...\n\n###############################################################################\nfrom htag.runners import PyScript\nPyScript( App ).run()\n\n&lt;/py-script&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n</code></pre> <p>source</p> <p>Pros</p> <ul> <li>you only need a browser ;-)</li> <li>Interactions are INPROC.</li> <li>no need of external libs</li> </ul> <p>Cons</p> <ul> <li>Launching the pyscript environnement can be long.</li> </ul>"},{"location":"runners/#runner-pywebview","title":"Runner 'PyWebView'","text":"<p>Run everything in a pywebview instance. The ideal solution to provide a \"python GUI app\".</p> <p>Run your <code>App</code> (htag.Tag class) like this :</p> <pre><code>from htag.runners import PyWebView\nPyWebView( App ).run()\n</code></pre> <p>source</p> <p>Pros</p> <ul> <li>Interactions are INPROC.</li> <li>the app can <code>self.exit()</code></li> </ul> <p>Cons</p> <ul> <li>til pywebview doesn't support async calls, full htag features (async) will not be available ;-(</li> <li>need external libs</li> </ul>"},{"location":"tag_update/","title":"tag.update()","text":"<p>This feature add a \"send from backend to frontend\" capacity, which can only work with Runners which have a \"permanent connexion\" with front end (think websocket)</p> <p>Note that this feature will not work, in this cases:</p> <ul> <li>When the Runner is in <code>http_only</code> mode (because this feature use websocket only) !</li> <li>With PyWebView runner, because pywebview doesn't support async things.</li> </ul> <p>It opens a lot of powers, and real time exchanges (see <code>examples/new_*.py</code>) ! and works for htagweb &amp; htagapk too.</p>"},{"location":"tag_update/#use-cases","title":"Use cases","text":"<p><code>tag.update()</code> is a coroutine, so you should use it in a coroutine only. It returns True/False depending on the capacity to update in realtime. (with http's runners : it will always return False)</p> <p>Here is an async method of an htag component (runned with a <code>asyncio.ensure_future( self.do_something() )</code>): <pre><code>    async def do_something(self):\n        self += \"hello\"\n        isUpdatePossible = await self.update()\n</code></pre></p> <p>Note that, the \"first updates\" can return False, while the websocket is not really connected. And will return True when it's done.</p>"},{"location":"tuto_create_an_input_component/","title":"How to create your first \"input\" component","text":"<p>I assume that you have the minimal bases (html's crafting and events bindings). And I will show you how to create an \"reactive\" input field .... it's, by far, the most complex thing ;-). But it's a component which cover well all the core features of htag concepts. If you understand that : you can start to craft your own/complex components easily.</p> <p>Let's create a minimal htag app, which is runn'able as is (if you got the dependencies for the DevApp runner):</p> <pre><code>from htag import Tag\n\n###############################################################################    \n# the app side\n###############################################################################    \nclass Test(Tag.body):\n    def init(self):\n        self &lt;= \"here, we want an input'able\"\n\n###############################################################################    \n# the runner side\n###############################################################################    \nif __name__==\"__main__\":\n    from htag.runners import Runner\n    Runner(Test).run()\n</code></pre> <p>Now, we want to create an input field. In the htag style, you will create something like that (replace your <code>Test</code> class):</p> <pre><code>class Test(Tag.body):\n    def init(self):\n        self &lt;= Tag.input(_value=\"default\" )        \n</code></pre> <p>Now, we've got an input field with a default value. Changing it, on UI side, does nothing.</p> <p>Let's change that (replace your <code>Test</code> class):</p> <pre><code>class Test(Tag.body):\n    def init(self):\n        self &lt;= Tag.input(_value=\"default\", _onchange = self.myonchange)\n\n    def myonchange(self,o):\n        print(\"it has changed\")\n</code></pre> <p>Now, changing it on UI side notify the python side, that something has changed ! The callback <code>myonchange</code> receive the object which has fired the event (o). But the input field has not sent its new content !</p> <p>Let's change that (replace your <code>Test</code> class):</p> <pre><code>class Test(Tag.body):\n    def init(self):\n        self &lt;= Tag.input(_value=\"default\", _onchange = self.bind( self.myonchange, b\"this.value\" ) )\n\n    def myonchange(self,value:str):\n        print(\"it has changed -&gt;\",value)\n</code></pre> <p>Assigning <code>_onchange = self.myonchange</code> is strictly the same as <code>_onchange = self.bind( self.myonchange )</code>. </p> <p>But the form <code>self.bind( &lt;method&gt;, ....)</code> is better when you need to send arguments. In this case, it will send the client value to the <code>myonchange</code> callback (using the <code>b\"trick\"</code> to get data from client/js side).</p> <p>It's better, but it will be a lot better to make it a \"htag component\", to be re-usable in another htag apps.</p> <p>Let's create a <code>MyInput component</code>, and reuse it from the main class <code>Test</code> like that:</p> <pre><code>class MyInput(Tag.input):\n    def init(self,value=\"\"):\n        self.value = value  # store the real value in a property value\n        self[\"value\"]=self.value    # set the @value attrib of html'input\n        self[\"onchange\"] = self.bind( self._set, b\"this.value\" )    # assign an event to reflect change\n\n    def _set(self,value:str): # when changed, keep the property value up-to-date\n        self.value=value\n\nclass Test(Tag.body):\n    def init(self):\n        self &lt;= MyInput(\"default\")\n</code></pre> <p>Now, when you change the content of your <code>MyInput</code> ... the change is reflected on python side !</p> <p>And you can rebind its onchange event, to get the changed value ....(replace your <code>Test</code> class)</p> <pre><code>class Test(Tag.body):\n    def init(self):\n        self.myinput = MyInput(\"default\")\n        self.myinput[\"onchange\"].bind( self.changed )\n\n        #construct the layout\n        self &lt;= self.myinput\n\n    def changed(self,o):\n        print(\"Changed -&gt;\",o.value)             # o is the object which has fired the event\n        print(\"Changed -&gt;\",self.myinput.value)  # or access direct to your reference\n</code></pre> <p>If you understand all that concepts ^^, you can start to build your own/complex components.</p> <p>Here is a login form, using our newly widget (replace your <code>Test</code> class):</p> <p><pre><code>class Test(Tag.body):\n    def init(self):\n        self.mylogin = MyInput()\n        self.mypass = MyInput()\n\n        #construct the layout\n        self &lt;= Tag.div(\"Login:\"+self.mylogin)\n        self &lt;= Tag.div(\"Passwd:\"+self.mypass)\n        self &lt;= Tag.button(\"ok\", _onclick=self.authent)\n\n    def authent(self,o):\n        if self.mylogin.value==\"test\" and self.mypass.value==\"test\":\n            self.clear()\n            self&lt;= Tag.h1(\"You are in ;-)\")\n        else:\n            self &lt;= Tag.li(\"not the rights credentials ;-)\")\n</code></pre> To go further</p> <p>You will notice that when you input bad credentials, the form is resetted to its initial values ! It's normal, because the <code>authent</code> method will modify the <code>Test</code> component's content (adding a <code>Tag.li</code> to <code>self</code>), which had the effect to force the redraw of the <code>Test</code> component on UI side !</p> <p>If you want to avoid this behaviour, simply add the <code>Tag.li</code> in another part of the UI (or simply remove the last 2 lines), like that :</p> <pre><code>class Test(Tag.body):\n    def init(self):\n        self.mylogin = MyInput()\n        self.mypass = MyInput()\n        self.result = Tag.div()\n\n        #construct the layout\n        self &lt;= Tag.div(\"Login: \"+self.mylogin)\n        self &lt;= Tag.div(\"Passwd: \"+self.mypass)\n        self &lt;= Tag.button(\"ok\", _onclick=self.authent)\n        self &lt;= self.result\n\n    def authent(self,o):\n        if self.mylogin.value==\"test\" and self.mypass.value==\"test\":\n            self.clear()\n            self&lt;= Tag.h1(\"You are in ;-)\")\n        else:\n            self.result &lt;= Tag.li(\"not the rights credentials ;-)\")\n</code></pre> <p>Because only <code>self.result</code> (Tag.div) is modified ... only <code>self.result</code> will be redraw on UI side.</p> <p>Now, you should really understand 95% of the core htag features</p>"},{"location":"tutorial/","title":"Tutorial","text":""},{"location":"tutorial/#construction","title":"Construction","text":"<p><code>htag.Tag</code> is the basic object, and the only one you'll need to use, to build an htag app. The simplest htag app could be :</p> <pre><code>from htag import Tag\n\nclass App(Tag.div): #&lt;= define the html tag container of the app\n    \"\"\" This is the most simple htag component \"\"\"\n\n    def init(self):\n        # I'm just a div'tag, with a textual node content \"hello world\"\n        self &lt;= \"Hello world\"   # shortcut for self.add(\"Hello world\")\n\nif __name__==\"__main__\":\n    from htag.runners import Runner\n    Runner( App ).run()    # &lt;= this is the runner\n</code></pre> <p>As you can notice, it uses the simplest constructor <code>init()</code>, to construct itself (best practice). But could be replaced by the real form too:</p> <pre><code>    def __init__(self, **kwargs):\n        # I'm just a div'tag, with a textual node content \"hello world\"\n        super().__init__(**kwargs)\n        self &lt;= \"Hello world\"   # shortcut for self.add(\"Hello world\")\n</code></pre> <p>The simplest form avoid you to deal with the real construction phase under the hood. Because <code>kwargs</code> are used to define html attributs (or instance properties) from the ground.</p> <p>Main Tag is always rendered as a body'tag</p> <p>Although <code>App</code> is declared as a <code>Tag.div</code>, it will be rendered as a body'tag, because it's the main Tag (the one which is drived by the runner)</p> <p>Here is another htag app, which will use the same component (MyText) for \"hello\" and \"world\". You can notice that, the second (\"world\") is set with a default background style (green). <code>kwargs</code> prefixed by <code>_</code> are automatically setted as attribut on the tag instance.</p> <pre><code>from htag import Tag\n\nclass MyText(Tag.span):\n    def init(self,txt, *a):\n        self &lt;= txt\n\nclass App(Tag.body):\n    def init(self):\n        self &lt;= MyText(\"Hello\")\n        self &lt;= MyText(\"World\",_style=\"background:green\")\n\nif __name__==\"__main__\":\n    from htag.runners import Runner\n    Runner( App ).run()    # &lt;= this is the runner\n</code></pre> <p>This will produce something like :</p> <pre><code>&lt;body id=\"140236411356880\"&gt;\n    &lt;span id=\"140236411356544\"&gt;Hello&lt;/span&gt;&lt;span style=\"background:green\" id=\"140236411356208\"&gt;World&lt;/span&gt;\n&lt;/body&gt;\n</code></pre> <p><code>id</code>'s are just here, to keep coherence with python objects on python side.</p> <p>If you want to set html attributs, at runtime (not in contructor phase), you simply set the dictitems of the Tag. Here is a version of the previous example using them.</p> <pre><code>from htag import Tag\n\nclass MyText(Tag.span):\n    def init(self,txt,color=None):\n        self &lt;= txt\n        if color:\n            self[\"style\"]=\"background:%s\" % color   # &lt;- here is the trick\n\nclass App(Tag.body):\n    def init(self):\n        self &lt;= MyText(\"Hello\")\n        self &lt;= MyText(\"World\",\"green\")\n\nif __name__==\"__main__\":\n    from htag.runners import Runner\n    Runner( App ).run()    # &lt;= this is the runner\n</code></pre> <p>It will produce the same html rendering.</p> <p>More on Tag creations (the complete guide)</p> <p>The tutorial to create an \"input\" component</p>"},{"location":"tutorial/#interactions","title":"Interactions","text":"<p>As you seen before, you can pass prefixed <code>kwargs</code> to define html attributs (or define them in the dictitems of the Tag), so this thing will work too :</p> <pre><code>from htag import Tag\n\nclass App(Tag.body):\n    def init(self):\n        self &lt;= Tag.button(\"Click me\",_onclick=\"alert(42)\")\n\nif __name__==\"__main__\":\n    from htag.runners import Runner\n    Runner( App ).run()    # &lt;= this is the runner\n</code></pre> <p>But, notice that the string which is setted in <code>_onclick</code> is just a javascript statement !</p> <p>If you want to call \"python side\", you will need to use an another form, the simplest one :</p> <pre><code>from htag import Tag\n\nclass App(Tag.body):\n    def init(self):\n        self &lt;= Tag.button(\"Hello\",_onclick=self.addContent)\n        self &lt;= Tag.button(\"World\",_onclick=self.addContent)\n\n    def addContent(self,object): # &lt;= object is the instance of the htag instance which have called this method (here a Tag.button)\n        self &lt;= object.innerHTML\n\nif __name__==\"__main__\":\n    from htag.runners import Runner\n    Runner( App ).run()    # &lt;= this is the runner\n</code></pre> <p>When you will click the button, the instance of the object will add \"some content\" to itself (you can verify, by refreshing the page (f5))</p> <p>kind of methods</p> <p>Here, the <code>addContent</code> method, is a sync method. But keep in mind, that it could be:</p> <ul> <li>a async method (ex: <code>async def addContent(...)</code>)</li> <li>a sync generator (ex: <code>def addContent(...): yield</code>)</li> <li>or an async generator (ex: <code>async def addContent(...): yield</code>)</li> </ul> <p>The last two (the generator ones), let you use a <code>yield</code> statement, which will force current rendering to the client side, while processing the generator.</p> <p>From here, you have seen 95% of the features of htag.</p> <p>More on interactions (the complete guide)</p>"},{"location":"tutorial/#include-ressources","title":"Include ressources","text":"<p>htag provide a way to include some external ressources (think: css, js, favicon, ...). All theses ressources will be included in <code>&lt;head&gt;</code> tag, at construction time. htag will scan the python Tag'classes and collect all of them to produce the heading parts of the html rendering.</p> <p>The trick is to define a class attribut <code>statics</code>, to add your ressource ... a simple example :</p> <pre><code>from htag import Tag\n\nclass App(Tag.body):\n    statics = Tag.style(\"\"\"body {background:yellow}\"\"\")\n\n    def init(self):\n        self &lt;= \"hello world\"\n\nif __name__==\"__main__\":\n    from htag.runners import Runner\n    Runner( App, port=9999).run()    # &lt;= this is the runner\n</code></pre> <p><code>statics</code> can be a Tag'instance or a list of Tag'instance.</p> <p>Discovering statics</p> <p>By default, htag will discover all Tag'subclasses to include their statics, from the current process. But sometimes, it can be useful to include only thoses which we really need ; it's possible thru the class attribut <code>imports</code>, which should contain a list of Tag'class.</p>"},{"location":"tutorial/#execute-js-statements-on-client-side","title":"Execute JS statements on client side","text":"<p>Sometimes, it can be useful to start a js statement ...</p> <p>or make a js interaction with @expose decorator</p> <p><code>** NEXT SOON **</code></p>"}]}